# from datetime import datetime, timedelta
# from typing import List, Optional, Dict, Any
# from uuid import UUID
# from sqlalchemy.orm import Session
# from sqlalchemy import and_, desc, func
# from database.base_repository import BaseRepository
# from database.models.alert import Alert
# from pydantic import BaseModel

# class AlertCreate(BaseModel):
#     anomaly_id: Optional[UUID] = None
#     job_run_id: UUID
#     alert_type: str
#     severity: str
#     title: str
#     message: str
#     recipients: List[str]
#     delivery_channels: List[str] = ["email"]
#     metadata: Optional[Dict[str, Any]] = None

# class AlertUpdate(BaseModel):
#     delivery_status: Optional[str] = None
#     delivery_attempts: Optional[Dict[str, Any]] = None
#     resolved: Optional[bool] = None
#     resolved_by: Optional[str] = None
#     resolved_at: Optional[datetime] = None
#     metadata: Optional[Dict[str, Any]] = None

# class AlertRepository(BaseRepository[Alert, AlertCreate, AlertUpdate]):
#     """Repository for alert operations."""
    
#     def __init__(self, session: Session):
#         super().__init__(session, Alert)
    
#     def get_by_job_run(self, job_run_id: UUID) -> List[Alert]:
#         """Get all alerts generated by a specific job run."""
#         return (
#             self.session.query(Alert)
#             .filter(Alert.job_run_id == job_run_id)
#             .order_by(desc(Alert.created_at))
#             .all()
#         )
    
#     def get_by_anomaly(self, anomaly_id: UUID) -> List[Alert]:
#         """Get all alerts for a specific anomaly."""
#         return (
#             self.session.query(Alert)
#             .filter(Alert.anomaly_id == anomaly_id)
#             .order_by(desc(Alert.created_at))
#             .all()
#         )
    
#     def get_by_severity(self, severity: str, limit: int = 100) -> List[Alert]:
#         """Get alerts by severity level."""
#         return (
#             self.session.query(Alert)
#             .filter(Alert.severity == severity)
#             .order_by(desc(Alert.created_at))
#             .limit(limit)
#             .all()
#         )
    
#     def get_by_alert_type(self, alert_type: str, limit: int = 100) -> List[Alert]:
#         """Get alerts by type."""
#         return (
#             self.session.query(Alert)
#             .filter(Alert.alert_type == alert_type)
#             .order_by(desc(Alert.created_at))
#             .limit(limit)
#             .all()
#         )
    
#     def get_pending_delivery(self) -> List[Alert]:
#         """Get alerts with pending delivery status."""
#         return (
#             self.session.query(Alert)
#             .filter(Alert.delivery_status == "pending")
#             .order_by(Alert.created_at)
#             .all()
#         )
    
#     def get_failed_delivery(self) -> List[Alert]:
#         """Get alerts with failed delivery status."""
#         return (
#             self.session.query(Alert)
#             .filter(Alert.delivery_status == "failed")
#             .order_by(desc(Alert.created_at))
#             .all()
#         )
    
#     def get_unresolved(self) -> List[Alert]:
#         """Get all unresolved alerts."""
#         return (
#             self.session.query(Alert)
#             .filter(Alert.resolved == False)
#             .order_by(desc(Alert.created_at))
#             .all()
#         )
    
#     def get_recent_alerts(self, hours: int = 24) -> List[Alert]:
#         """Get alerts created within specified hours."""
#         cutoff_time = datetime.utcnow() - timedelta(hours=hours)
#         return (
#             self.session.query(Alert)
#             .filter(Alert.created_at >= cutoff_time)
#             .order_by(desc(Alert.created_at))
#             .all()
#         )
    
#     def get_critical_alerts(self, hours: int = 24) -> List[Alert]:
#         """Get critical alerts within specified time period."""
#         cutoff_time = datetime.utcnow() - timedelta(hours=hours)
#         return (
#             self.session.query(Alert)
#             .filter(
#                 and_(
#                     Alert.severity == "critical",
#                     Alert.created_at >= cutoff_time
#                 )
#             )
#             .order_by(desc(Alert.created_at))
#             .all()
#         )
    
#     def mark_as_sent(self, alert_id: UUID, delivery_details: Dict[str, Any]) -> bool:
#         """Mark alert as successfully sent."""
#         alert = self.get(alert_id)
#         if alert:
#             alert.delivery_status = "sent"
#             if alert.delivery_attempts is None:
#                 alert.delivery_attempts = []
            
#             delivery_details["timestamp"] = datetime.utcnow().isoformat()
#             delivery_details["status"] = "success"
#             alert.delivery_attempts.append(delivery_details)
#             self.session.commit()
#             return True
#         return False
    
#     def mark_as_failed(self, alert_id: UUID, error_details: Dict[str, Any]) -> bool:
#         """Mark alert delivery as failed."""
#         alert = self.get(alert_id)
#         if alert:
#             alert.delivery_status = "failed"
#             if alert.delivery_attempts is None:
#                 alert.delivery_attempts = []
            
#             error_details["timestamp"] = datetime.utcnow().isoformat()
#             error_details["status"] = "failed"
#             alert.delivery_attempts.append(error_details)
#             self.session.commit()
#             return True
#         return False
    
#     def resolve_alert(self, alert_id: UUID, resolved_by: str) -> bool:
#         """Mark alert as resolved."""
#         alert = self.get(alert_id)
#         if alert:
#             alert.resolved = True
#             alert.resolved_by = resolved_by